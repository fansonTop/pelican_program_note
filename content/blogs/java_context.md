Title: java的一些基本概念
Date: 2021-10-25 00:10
Category: java
Tags: java, context
Authors: Fanson
Summary: 对java的一些基本概念总结

---------------------------------

### package（包）

1. 对包的描述  
   1.1) 将不同功能或不能模块的java文件，分类管理，方便寻找  
   1.2) 不同的两个包可以有同名的类  
   1.3) 实际上：每个类的全称 = 包名 + 文件名  
   1.4) 包名全部单词字母小写，如果多个单词组成包名，可以用点分隔  
   1.5) 企业中标准包名格式，通常使用域名反写原则  

2. import导入  
   2.1) 定义：导入指定类到当前包，导入制定类之后，当前包就可以直接使用这个类  
   2.2) import的用法：import <包名>.<类名>;  
3. 注意事项：  
    * 如果导入了一个和当前包中的类同名的类，使用的是导入的类  
    * 在同一个类中不允许使用import导入同名的两个类  
    * 使用*导入的类的优先级低于使用类名导入的类

4. java中默认导入java.lang.*


---------------------------------

### 访问修饰符

1. 定义：规定类中的属性和方法可以由谁调用的修饰符
2. 必要性：隐藏一些不必要让用户调用的成员，提高程序的封装性
3. 访问修饰符的类型：  
   3.1) public  
   3.2) protected  
   3.3) 默认  
   3.4) private

4. 访问修饰符的修饰效果  
      |       | 本类  | 同包  | 不同包的子类| 其他   
   ---|:---:  |:---:  |:---:  |    :---:    | :---:  
   public     |  ☑️   |    ☑️  |   ☑️     |  ☑️    
   protected  |  ☑️   |    ☑️  |   ☑️       
   默认       |  ☑️   |    ☑️  |     
   private    |  ☑️     

5. 访问修饰符的注意事项  
   5.1) 类中的属性和方法：可以使用四种访问修饰度修饰  
   5.2) 类-class只能使用public或默认修饰符修饰  

---------------------------------

### final关键字

1. 定义：就是一个表示“最终”状态的修饰符
2. final使用：  
   2.1) 修饰类：被final修饰的类不能被继承  
   2.2) 修饰方法：被final修饰的方法不能被重写  
   2.3) 修饰属性：  
      > 被final修饰的属性值不能修改  
      > 被final修饰的属性，没有默认值，所以必须赋值  

   2.4) 修饰局部变量
      > 被final修饰的局部变量初始化之后不能被修改，用final修饰形式参数，形式参数不能修改值

---------------------------------

### static关键字

***static 静态***

1. 修饰属性  
   1.1) 被static修饰的属性称之为静态属性或者类属性  
   1.2) 静态属性的值时这个类的所有对象共享的  
   1.3) 静态属性会被JVM保存到方法区  
   1.4) 静态属性适合所有对象共享的资源保存起阿里，能节省内存  
   1.5) 静态属性官方建议使用类名调用

2. 修饰方法  
   2.1) 被static修饰的方法称之为静态方法或者类方法  
   2.2) 静态方法和静态属性一样，可以使用类名调用，所以调用静态方法可以不实例化对象，直接调用  
   2.3) 静态方法中不能使用this关键字  
   2.4) 如果这个方法中不涉及任何当前对象的实例成员，就可以设置为静态方法 

3. 修饰初始化块  
   3.1) 定义：  
      > 编写初始化块，能在构造方法执行之前执行指定代码  

   3.2) static修饰初始化块，称之为静态初始化块或静态块  
   3.3) 静态块在类中被加载到JVM时运行一次，类只会被加载一次，所以静态块只会运行一次  
   3.4) 如果一些代码程序只会运行一次，就可以写在静态块中  
   3.5) 通常静态块用于加载程序运行时需要的资源  

---------------------------------

### 常量

1. 定义： 程序中那些不会变化的特定值  
2. 为什么使用常量
   > 在程序中反复出现的某个特定值，可以使用常量代替，提高程序的可维护性  
3. 常量的定义方法

   ```java
   public final static <类型> <名称>
   ```

4. 常量的特征  
   4.1) final带来的特征：常量的值不能被修改  
   4.2) static带来的特征：只保存一份，使用类名调用  
   4.3) final和static组合带来的额外好处：在编译时就会将常量的值带入到调用位置，而不是运行时再读取  
   4.4) 常量的命名规范：所有字母均大写，单词间隔用_分隔 

5. 常量的赋值  
   5.1) 一般情况下：都是声明时赋值  
   5.2) 特殊情况下：可以在静态块中赋值  

---------------------------------

### 抽象类

1. 定义：在程序中不存在对象，或不使用这个类对象的类  
2. 如何定义抽象类：
   > 在class前家abstract关键字
3. 抽象方法  
   3.1) 抽象类不能实例化  
   3.2) 抽象类中能够编写抽象方法  
   3.3) 抽象类中的抽象方法数量不限  

---------------------------------

### 抽象方法

1. 定义：抽象方法是没有方法体的方法
2. 怎么定义抽象方法：
   > <修饰符> abstract <返回值> <方法名>(参数列表)

3. 抽象方法的特征
   1. 抽象方法没还有方法体
   2. 子类中必须重写父类中的抽象方法，除非子类也是抽象类
   3. 抽象方法必须在抽象类中

   > ***ps:abstract和final关键字，是冲突的***

4. 抽象类和抽象方法的意义
   1. 减少项目中可实例化的类型
   2. 抽象类适合为子类提供共有的属性和方法
   3. 更自然的使用向上造型并调用子类重写后的方法

---------------------------------

### 内部类

1. 定义：一个创建在类内部的类
2. 怎么定义内部类

   ```java
      class Outer {
         class Inner{}
      }
   ```

3. 内部类说明
   1. 成员内部类能使用四种访问修饰符
   2. 内部类和外部类的似有属性可以相互访问
   3. 当外部类和内部类的成员同名时，内部类中直接调用是内部类的成员，要想调用外部类的成员需要:
      >>> <外部类名>.this.<成员>
   4. 一般情况下内部类的使用只在外部类中通过内部类减少java文件数量
   5. 每个内部类都会有自己独立的class文件

---------------------------------

### 匿名内部类

1. 说明：
   > 一般情况下，匿名内部类指在方法中通过继承类或实现接口来编写的没有名字的内部类
2. 特点：
   1. 外部类的私有属性，匿名内部类可以使用
   2. 外部类和内部类的成员如果重名，直接调用是内部类的，如果想调用外部类的<外部类名>.this.<成员>
   3. 匿名内部类实在方法中就地编写某个类的子类，并且向上造型，只能使用在声明他的方法中
   4. 当需要继承一个父类，而且这个子类对象只使用一次时，就可以在使用这个子类对象的位置通过匿名内部类来实现
   5. 每个内部类都会有自己独立的class文件
   6. 匿名内部类如果要使用它所在方法的局部变量，必须将这个局部变量视为被final修饰的
   7. JDK1.7之前，在匿名内部类中使用它所在方法的局部变量，必须将这个局部变量设置为final修饰才可以
3. 匿名内部类展示:

   ```java
      public class TestDemo {
         private int a;

         public void work() {
            Fruit fruit = new Fruit() {
               int a;
               public void eat() {
                  a = 20;
                  System.out.println(TestDemo.this.a);
                  System.out.println(a);
               }
            };
            fruit.eat();
         }

         public static void main(String[] args) {
         TestDemo testDemo = new TestDemo();
         testDemo.work();
      }
   }

   public abstract class Fruit {
      public abstract void eat();
   }
   ```

---------------------------------

### 计时器

1. 定义：能按照约定好的时间间隔，周期性的调用指定方法的对象
2. 如何定义一个计时器:

   ```java
   Timer timer = new Timer();
   ```

3. 定义要调用的指定方法，使用匿名内部类实现一个TimerTask类的子类，重写类中的run方法
4. 启动计时器：Timer对象的schedule方法，启动计时器周期调用方法即可
5. 示例：

   ```java
   import java.util.Timer;
   import java.util.TimerTask;

   public class TimerDemo {

      public void start() {
         Timer timer = new Timer();
         TimerTask task = new TimerTask() {
            int i = 1;
            public void run() {
               System.out.println(i);
               i++;
            }
         };
         timer.schedule(task, 1000, 1000);
      }

      public static void main(String[] args) {
         TimerDemo timerDemo = new TimerDemo();
         td.start();
      }
   }
   ```

---------------------------------

### 接口

1. 定义：接口是java中的一种特殊数据类型，可以将接口看作是一种特殊的抽象类
2. 接口的作用：因为java中允许一个类实现多个接口，从而间接的实现java的多继承
3. 接口定义的关键字：interface
4. 编写接口注意事项：
   1. 在接口中编写属性，这个属性会变为公有静态常量，即被public static final修饰的
   2. 在接口中定义方法，这个方法会变为共有抽象方法，即被public abstract修饰
   3. 在接口中编写静态方法或在接口中编写默认方法（）
5. 实现一个接口：
   > 定义一个类实现一个接口，要重写接口中的所有方法，除非这个类是抽象类，一个类可以实现多个接口，接口之间用，分隔

   ```java
   class A implements <接口名> {}
   class A extends B implements <接口名> {}
   ```

6. 使用接口的原则：
   > 使用继承的原则符合is-a的关系  
   > 使用接口的原则符合has-a的关系
7. 使用接口类型调用方法
   1. 接口本身不能实例化
   2. 实例化实现类对象赋给接口引用也是向上造型
   3. 接口类型的引用只能调用到接口声明的方法
8. 使用接口的注意事项
   1. 接口可以继承接口使用extends关键字，继承多个接口用，分隔
   2. 接口特别适合用于设计程序中的多种功能，这个设计的过程称之为面向接口变成，就是只写接口不写实现
9. 示例：

    ```java
    public interface A {
       int MY_PARAM = 5;
       void func();
    }

    ```

---------------------------------

### 多态

1. 概念：多态可以理解为多种形态，一个父类的多个子类，多同一个方法的调用展现出来的不同操作
2. 为什么使用多态：减少代码冗余，提高扩展性，维护性
3. 使用方法步骤
   1. 定义一个接口（父类）
   2. 定义一个子类（实现类）重写父类（接口）的方法
   3. 子类对象赋给父类引用
   4. 父类引用调用子类重写后的方法
4. 引用类型的强制类型转换
   1. 父类（接口）引用无法调用到子类（实现类）中独有的属性或方法，将父类（接口）引用强制类型转换为子类（实现类）的类型，来调用它独有的成员
   2. 如果转换的目标类型不是引用的真实类型，可能发生类型转换异常：ClassCastException
   3. 要防止这个一场需要使用instanceof关键字做判断
   4. instanceof使用方法

      ```java
      <引用> instanceof <类型>
      ```

---------------------------------

### GC(垃圾回收管理机制)

1. 程序垃圾:程序中再也无法使用到的对象或资源
2. 为什么处理垃圾：占用内存，内存溢出，内存泄露
3. 怎么清理：
   1. C++中需要程序员编写析构函数，在不使用这个对象时，调用这个对象的析构函数
   2. JAVA中，GC会自动识别系统中的垃圾
4. GC优缺点：
   1. 程序员不需要考虑垃圾回首，专注于代码逻辑
   2. GC本身占用内存，GC回收垃圾有延迟
5. GC回收原理
   1. 引用计数法：根据一个对象的引用数量判断这个对象是否是垃圾
6. finalize方法：object类中定义的一个方法，GC在回收该对象前会调用这个对象的finalize方法
7. System.gc()方法：同志GC尽快回收垃圾